# 领域驱动设计 （Domain Driven Design） ... 持续更新中 
这个题目拖了很久了，一直没有时间把自己的学习和领会写下来，这都2020年了，完成它！本文主要内容来自Eric Ewens的《Domain Driven Design》一书，结合了我的一些理解和实践经验，希望对读者有帮助。同时这里你可以下载到我自己准备的用于培训的PPT，既然是PPT那内容肯定很粗略，但可以当个大纲看。  

大多数做微服务开发的同学对DDD这个名词肯定不会陌生，至少是听说过的。当我们面临从传统Monolithic系统转向微服务构架时，第一个问题就是怎么划分出微服务，它们之间如何关联，怎么进行全系统设计？数据一致性如何在微服务之间保持，微服务的“先民”们也不例外要面临这些问题，神奇的是大家忽然发现这些问题在Eric的DDD一书中都有讨论和结论，于是 DDD名声鹊起~现在到了谈微服务必谈DDD的地步（除非你是码农一个，只动手不动脑，按领导要求抱着Spring Cloud全家桶一顿整，那确实，DDD与你无关） 从这个角度来上说，是微服务“成就了”DDD啊。这里我们要明确一下，是DDD成书在先，微服务出现在后，所以在DDD全书中你找不到“微服务”这个名字，虽然到处都是微服务的影子。

DDD一书到底讲述了怎样的理论呢？其实特别简单：**软件设计要以业务领域概念为一个稳定的核心，全员（产品，开发，测试）参与共同建模出本领域模型并不断“重构”它**。书中阐述了衡量良好模型的多个维度，并从这些维度上给出具体技巧（作者喜欢称之为“Pattern”，模式）来指导我们建模。

## 一· 软件项目为什么容易失败  
我印象中10年前（甚至今天）软件项目简直就是“延期”“超预算”的代名词 （但愿这种印象只是我本人的错误感觉，如果开发项目规模相对较大，确实不容易掌控，把谁搬来都不好使）。Eric根据自己的经验给出的原因是：软件开发本来就复杂度很高，更要命的是产品人员和设计人员（Arch），设计人员和开发人员之间都存在信息的丢失和“变形”，不采取点儿“手段”能按时按点儿保质保量地做出来才怪呢！  

### 软件复杂度哪里来  
首先是实施阶段，真正开发的同学（码农？）要确保已经正确理解了业务上要做什么，然后是理解了可能是其他同事完成的设计，最终能不折不扣的反应到代码中去，整个这个链条就涉及很多对接点儿，完全不出岔子不容易。  即使一路顺利功能都完美实现了，那还有我们的实现是不是具有扩展性和“皮实”的特点，这个和下一点相关。  
然后呢是后期的增强和支持，一个软件上线后，后期基本都需要进行再增强的，那经常出现的情况是当初开发被增强功能的那个人已经离开了，到哪里去找原始的设计想法啊！你说“文档”？做过软件工程的都知道那能起多大作用。那么最后的行动方案很可能开发人员自己读一遍代码，根据自己的理解提出个解决方案，Review后实施之~。那么好，到此为止这个功能点已经有2个（波）人的思路在里面了，设想一下这样来几次后，咱的体系结构会是个啥模样。按我的话说就是怎么样才能让我们的架构久经折腾而不变形不走样，那是门学问啊。  
最后呢从使用者的角度来看，我们的产品API（如果有）需要稳定而且易懂，不能说使用我们的接口的产品需要读一遍我们接口对应的代码后，才能完全知道（才能放心）怎么使用它们。要达到这种效果不容易。  

如果我们从这三个维度上看，可以明显的感觉到软件开发本身就具有复杂性，容易变得混乱和失控。

### 信息的丢失  
我们经常在各种培训中做一个“传话”游戏，大家占成一排，过程中不能互相看，教练告诉排头一句话或一个动作，让大家逐个传递下去，音量只能耳语级别，在我的经历中居然没有一次是到最后不走样的。所以说，人和人之间的交流是易错的，最好的方式集体参与，互相验证。Eric也持有类似观点。  
![models](images/ddd1.PNG)  
他观察到“分析模型”往往和用于最后实施的“技术模型”对不上号，因为“分析模型”主要是产品和几个高阶技术人员完成的，而“技术模型”是开发人员一起根据对分析模型的理解给出的，那会错意肯定不能避免的。

### 怎么办？  
DDD的核心主张是找出那个软件所在领域内的概念，用这些概念构建起足以支撑我们软件的领域模型，这个模型全项目组共享，大家都在一个知识的水平线上。项目组日常交流也要建立在以这组概念为基础的“Ubiquitous Language” （通用语言）上，关于需求的讨论必须要有各个角色的共同参与，特别是要把开发人员纳入进来因为是他们去最终实施。DDD还明确好的设计是易懂的设计！这个原则简直太对了，cannot agree more! 如果说小一点到技术实现级别的话，我们有理由鄙视那些过于追求精炼而让代码难懂或藏雷的设计。在DDD的“柔性设计”部分作者专门讨论了如何在领域模型设计层面让我们的模型易懂。另外DDD主张“化整为零”，把大型系统的开发根据团队结构（例如地理分布），概念的耦合度等原则划分为不同的部分，称为bounded Context, 交给一个个小团队去负责，你看，这个就和微服务想干的事情很一致了。

DDD主张引入“**领域层**”。  分层的思想很早就被用于软件开发，例如烂大街的MVC模式实际上就是把UI，逻辑和DB分开，形成三个层次，上层会去用下层，但下层不会去使唤上层，这是分层的本质。
![领域层](images/ddd2.PNG)  
把领域层分出来的目的是单独管理，让这个最为重要的层次稳定健壮，并摆脱上面Application层次需要处理的协调工作和下面Infrastructure层要提供的基础服务，变得精炼。我感觉单独把领域放在一层也是很朴素的想法，技术人员在着手实现领域模型时必然会把它“抽出来”,单独管理。

DDD要求在每个Bounded Context范围内建立Ubiquitous Language （通用语言），在20年前提出这样的概念真的很了不起。建立通用语言的目的拉平产品，开发等项目参与人员的知识水平，从而减少交流中的误解，提高交流效率。做项目过程中交流成本真的很大，处理不好那就是拖延的根源，特别是旷日持久的产品类开发，人员在经年累月的开发和增强工作中会逐步更换，如果来一个新人就让他从0知识开始慢慢成长到全组水平的话，拿着活儿没法保证质量和速度了，还不够给新人填坑呢。

## 二·领域模型建模元素
既然DDD围绕领域模型展开，我们一起来看看模型中都包含哪些基本元素。这里不得不唠叨一下，我特别佩服老外这种总结和拔高儿的能力，很多我们脑子里有但很难描述清楚的东西人家可以三言两语说的清清楚楚而且高大上，这种抽象思考能力是我辈非常欠缺的。  
* Entity（实体）  
代表一个有ID的概念，概念上会有“状态”通俗讲就是属性信息。它的每个实例都会有身份标识，在我们的应用中需要区分对待不同实例。感觉有点儿像面向对象里面的类吧。
* Value Object （值对象）  
代表一个无ID的概念，其上也会有“状态”，但它的显著特点是VO的实例一旦初始化完成，其内部状态后续都是不会更改的，这是它和Entity最大的区别。举个例子吧，系统中订单的Status（Initial，In Process， Closed）可以是一个VO，这个VO可能的实例有三个: Initial, In Process, Closed，这三个Status实例可以被整个系统中的订单来共享，也就是说，不必每个订单都声明状态实例，直接复用这三个里面的一个就ok了。  
* Service （服务）  
这个就好理解了，它上面承载操作，并且呢它内部不包含状态信息。  
* Aggregate （聚集）  
作者并没有把Aggregate作为DDD领域模型元素来介绍，但我感觉它完全可以作为一个基本元素。它代表了一组紧密相关的Entity，每个Aggregate里面有且仅有一个‘Root’ Entity。 Aggregate有个特性，它自己要负责自己内部的一致性，我们外部不需要关心，外部在和Aggregate打交道时一定是通过Root Entity进行的，无法直接接触非Root Entity。所以它带给我们模型的好处是，把一组Entity形成一个自治有机体，简化了模型。  

这里需要指出的是，一个概念到底是那种类型 - 是Entity还是VO还是其它什么 - 和你的建模思路紧密相关，没有唯一正确答案一说，你只要在Bounded Context内始终保持统一理解，不要朝三暮四就ok了。

现在有了这些元素，你就可以开始你的建模之旅了。想一想你的软件领域内哪些可以做为Entity，哪些更合适做为VO，等等，以一种整个项目组都能理解的表示方式表述出来，那么你的模型就形成了。当然现实肯定没有我说的这么easy :-)，能熟练完成这个过程前需要大量学习和实践，这个就靠个人的努力了。DDD不强调用什么方式去表述模型，最最朴素的框框图可以，严谨的UML图也挺好，纯粹文字描述也不是不能接受，全看项目组的喜好。

## 三·管理模型元素生命周期  
DDD首先探讨了如何管理模型元素的声明周期，主要是怎么创建创建出实例来，接下来如何管理这些实例，保证一致性，遍历实例等等。  
### 实例的创建 - Factory模式  
Eric把自己建模过程中的一些技巧，窍门统统叫做“Pattern”，模式，也鼓励借鉴技术领域的设计模式（那23中经典设计模式）的思想用于构建领域模型，这往往让读者困惑，我们要始终记得我们在讨论领域模型的事情，即使某些模式名字“恰巧”和设计模式一致，我们也只是用它的思想，而不是要建立出设计模式里该模式应有的类（角色）。  

DDD特别担心建模者的注意力分散，例如需要处理复杂概念的实例创建，或者处理Aggregate的创建，那么一下子大家的思路就分散到技术细节上去了，有没有办法把这些复杂性屏蔽掉呢？马上想到了设计模式中的‘Factory’模式，它的思想可以借鉴过来嘛：**我们为复杂概念配备Factory，它专门负责构建实例，每当我们需要该概念实例的时候直接去找这个Factory要。** 经过这么一包，领域模型层面就清爽了，当然这个Factory有可能有许多繁琐的技术细节，那对不起，咱领域模型层面不操这心，留给技术实现吧。  
![factory模式](images/dd3.PNG)  
DDD建议我们的Factory要保持两个原则：  
* 创建的原子性：一次给足Factory需要的构建参数，一次完成创建。我感觉作者是强调不要采用Builder模式的思想，一点点逐步构建，因为那样的话需要调用者去理解创建的逻辑，违背了封装复杂性的目的；  
* Factory要独立存在：不要让概念本身承担Factory的职责，因为DDD提倡概念清晰化，职责单一话，你把复杂的实例创建逻辑都放在那个概念上不是让它很繁琐嘛？
### 实例的遍历 - Repository模式  
对于那些被全局访问和使用的Entity，我们要为它们每人都配备一个Repository，使用过JPA的同学可以用JPA里面的Repository类比一下。这里说的“全局访问”是相对于Aggregate里面非Root Entity的其它Entity说的，那些Entity根本不会在Aggregate之外直接访问，所以没有必要配备Repository。  
对于普通Entity，Repository会负责创建，返回，删除Entity实例；而对于Aggregate，Root Entity的Repository负责了整个Aggregate，因为外部不会和非Root Entity的其它Entity直接打交道嘛。  

## 隐式概念显示化  
前文提过，DDD特别在意模型的清晰易懂，发现领域中很多“潜规则”并把它们明显地大声地表述出来是很重要的，只有把隐藏的概念，逻辑都显示化地表述在模型里，才能得到我们向往的“深层模型” - 指一种全面，清晰的领域模型。为了达到这种境界，我们需要敏感地注意发现那些隐藏的概念，例如通过：
* 倾听领域专家讨论时使用的语言。看是否有新词出现，这词没有在我们的Ubiquitous Language中；或者专家纠正了我们的一些用词；在讨论进行过程中有没有力不从心，词不达意？
* 不断检查现有模型，发现不足。思索当前设计的蹩脚之处
* 多读书，借鉴其他人的模型  

### 技巧 - 把过程建模进模型  
所谓“过程 Process”，是指一系列操作和处理的过程，在我们的软件中，总是会有些特别重要和处理过程的，它们太重要了，我们需要把它们明显的放置在模型中，回顾我们手里的模型元素会发现，Service非常适合承载过程，那我们就可以使用它。  
另外，我们也经常遇到过程本身有多种替代方案的情况，条条大路通罗马，做一件事本来就很少只能用一种方式，那么建模这样的模型时该怎么处理？我们可以参考设计模式里面的“Strategy”模式的思想，把各个方案都做成“Strategy”。  

注意不要乱，这里的重点是，那些重要的过程我们最好把它们单独建模在模型里，不要把它们隐藏在相关的Entity中。

### 技巧 - 把约束建模进模型  
所谓“约束 Constrain”，是指我们模型元素需要满足的各种规定，这些规定往往是领域所要求的，这个也很好理解，各行各业都有自己的要求嘛。从某种意义上来说，正是这样的约束，刻画出了我们的领域，所以我们要尽量把重要的约束建模进模型中。其实即使不显示地放在模型中，这些约束也不可能被我们在实施过程中丢掉，最简陋的做法是把这些约束重复地放在相关的Entity上，问题是重复本身就是一种很傻很浪费的行为，但如果只放在一个Entity上呢那就更严重了，这个Constrain污染了我们的Entity：破坏了该Entity的概念完整性。那么怎么为约束建模更好呢？  

DDD在这里隆重推出了它很得意的**“Specification”模式**，号称是Eric和另一个牛人一起创建的。一个Specification是一个Value Object，它里面有一个个的谓词操作，所谓谓词操作就是返回对或错的操作，每个谓词操作都代表了对一种约束或规则的检验，检验结果自然是有过和不过两种。通过这种方式我们把重要的约束和业务规则都清楚地放在了模型中。

Specification有一个很有意思的特性，它的谓词可以通过逻辑操作符进行组合，例如 True AND False = False，如果我们所设定的谓词足够小，那么我们的代码可以方便的按照业务逻辑的变化而调整。

## 柔性设计 （Supple Design）  
软件的目的当然是服务于最终使用者，但软件自身的开发，增强和维护都离不开开发者，开发者是一个软件的隐形消费者。软件的设计的优劣，不完全决定于是否完成了既定的功能以及多么出色地完成了这些功能，还在于它后期的演化能力，历经演化而不死的健壮性，这需要软件的初始设计充分考虑后续开发者。易于理解，（内部接口）易于使用，易于增强是衡量优秀设计的重要标准。  

在这一大部分，DDD主要探讨怎么让领域模型容易理解。