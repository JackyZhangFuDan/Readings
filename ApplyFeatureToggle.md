# 应用功能触发器 （Feature Toggles）

在[上一篇](FeatureToggle.md)中我们摘录了Martin Folwer个人网站的文章，了解了Feature Toggle的思想，这里我汇总一些在实际应用时需要用到的点，有的是个人想法，有的来自网络。

## 首先要明确下自己Toggle的目的  
就是我们这个toggle是为了什么而引入的，我觉得这个很关键，搞不清楚定位的话随着时间的拉长，toggle数量的增多，一定会出现混乱。在[这个链接给的best practice](https://featureflags.io/feature-flags-best-practices/)中也首先提到“Choose the Right Level of Flagging”， 实际上是一回事。  

上一篇的作者把Toggle分了几个类别（Release Toggle，Experiment Toggle，Ops Toggle，Permission Toggle），同时按照存在时长和Toggle决定过程的动态性两个维度对这几类Toggle进行了划分，这实际上给了我们定位自己Toggle的很好的指引。觉得Ops Toggle最有可能是开发人员发起的toggle类型，而其它三种更倾向于由产品需求驱动的。  

搞清楚我们Toggle的定位之所以重要，是因为它可能会影响我们对它的实现和管理，这个在上一篇里作者已经介绍了，我觉得很有道理。例如长期存在的toggle那么我们代码设计时就有必要按照我们产品功能代码的要求进行，可维护性，健壮性，可扩展都可以考虑；而如果短期使用那完全没有必要。再例如对于Ops Toggle，用数据库存储其当前配置值并配以Admin UI进行切换就比较合适，通俗易懂。

## 对于Release Toggle，它不是决定新代码的启用与否  
而是用它去开关***新功能***，因为这种toggle是产品经理决定打开与否。也就是说，如果我的一个改动不会带来产品功能的变化，用户界面不会变，产生数据不会变......等等，只是我开发人员做了一些改进或代码增强或代码重构，那完全没有必要用Release Toggle保护。那我们作为开发人员对一些代码改进没信心，想留个后手可以迅速新老切换怎么办？这样的话可以引入Ops Toggle，或Experiment Toggle也将就，这是开发自己的事情，PO没必要知道了。  

## 什么时候引入Toggle，什么时候不用考虑？  
这个肯定是和我们项目用Toggle的目的有直接关系。例如在我们的项目中，PO要求每个产品功能都有toggle，然后由PO组决定何时，哪些功能被release （这实际上是Release Toggle），那么我们开发人员在不***意图***改变功能的前提下是可以不加toggle的，反之，影响到功能了，PO也在意那必须加toggle，这个不是技术上的问题，往大了说是产品策略的问题，不是开发人员说了算的。这里其实有个潜在待明确的概念：什么是功能什么不是功能，我觉得答案可以很简单：PO提出的，在意的就是功能，她不知道的不在意的就是不是。

## 如果一个新功能的开发触及了对已有数据库表格的结构的改动，这时Toggle还能做吗？  
这个场景经常被拿出来讨论，要求是：新的功能只有在toggle打开时才起效，在此之前老的功能起效，有新老切换的可能。这实际上要求了***在一段时间内，我们的代码同时提供了新老功能***，随着toggle的开与关在两者之间切换；但我的改动触及了数据库结构了，不做处理这极有可能会破坏老的功能。  

为了支撑这种产品策略，针对这类开发，我想可以分几步走：
- 第一步，目标是对数据库进行兼容性修改，让它足以支撑新老功能  
像加个字段，加个表这种改变本身就不会破坏已有数据，直接可以在数据库上进行。如果是字段截短，那么也可以先不动，去下一步改代码，让所有数据渐渐都变成截断后的状态（是不是可以考虑直接写个migration程序？也可以嘛）。如果是删除字段或删除表那我们在这一步就可以什么都不做，去调整代码，然后等到第四步再干掉。
- 第二步，目标是让老的功能可以在改后的数据库结构上运行  
做好这一步我们就可以向线上去push了，因为老功能还在并可运行。  
- 第三步，目标是加入新功能，提供Feature toggle  
数据库都改好了，这里要加新代码引入新功能，如果注意保护老代码，这步应该比较容易达成。  
- 第四步，目标是移除feature toggle，清理数据库
feature toggle没必要之时，就是我们新功能完全取代老功能之日，那我们就可以放心去清理数据库了。现实中我们不能忘记这一步，不然长尾效应会给项目组带来许多负担。  

上面这个过程肯定不能解决所有的复杂数据库改动问题，但大多数的情况应该行的通，大规模不兼容改动一直发生是不太正常的。同时我们也可以把一个特别大的改动碎片化，经过一段时间的逐个处理，最终达到目的。

其实技术手段肯定有，主要是我们自己思想上要有“能做”的信念，而不是咬定“不好做”去推PO不做这个功能或是牺牲新老切换的便利。

另外在这个[链接中](https://featureflags.io/feature-flags-database-migrations/)，作者分析了完全的数据库切换 - 开始用MangoDB，之后切换到其它一种 - 时如何用toggle来辅助完成，比较有启发性，建议看看。总的来说步骤可以用下图描述：  
![dbmigration](images\ft5.jpg)