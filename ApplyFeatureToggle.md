# 应用功能触发器 （Feature Toggles）

在[上一篇](FeatureToggle.md)中我们摘录了Martin Folwer个人网站的文章，了解了Feature Toggle的思想，这里我汇总一些在实际应用时需要用到的点，有的是个人想法，有的来自网络。

## 首先要明确下自己Toggle的目的  
就是我们这个toggle是为了什么而引入的，我觉得这个很关键，搞不清楚定位的话随着时间的拉长，toggle数量的增多，一定会出现混乱。在[这个链接给的best practice](https://featureflags.io/feature-flags-best-practices/)中也首先提到“Choose the Right Level of Flagging”， 实际上是一回事。  

上一篇的作者把Toggle分了几个类别（Release Toggle，Experiment Toggle，Ops Toggle，Permission Toggle），同时按照存在时长和Toggle决定过程的动态性两个维度对这几类Toggle进行了划分，这实际上给了我们定位自己Toggle的很好的指引。觉得Ops Toggle最有可能是开发人员发起的toggle类型，而其它三种更倾向于由产品需求驱动的。  

搞清楚我们Toggle的定位之所以重要，是因为它可能会影响我们对它的实现和管理，这个在上一篇里作者已经介绍了，我觉得很有道理。例如长期存在的toggle那么我们代码设计时就有必要按照我们产品功能代码的要求进行，可维护性，健壮性，可扩展都可以考虑；而如果短期使用那完全没有必要。再例如对于Ops Toggle，用数据库存储其当前配置值并配以Admin UI进行切换就比较合适，通俗易懂。

## 对于Release Toggle，它不是决定新代码的启用与否  
而是用它去开关***新功能***，因为这种toggle是产品经理决定打开与否。也就是说，如果我的一个改动不会带来产品功能的变化，用户界面不会变，产生数据不会变......等等，只是我开发人员做了一些改进或代码增强或代码重构，那完全没有必要用Release Toggle保护。那我们作为开发人员对一些代码改进没信心，想留个后手可以迅速新老切换怎么办？这样的话可以引入Ops Toggle，或Experiment Toggle也将就，这是开发自己的事情，PO没必要知道了。  

## 什么时候引入Toggle，什么时候不用考虑？  
这个肯定是和我们项目用Toggle的目的有直接关系。例如在我们的项目中，PO要求每个产品功能都有toggle，然后由PO组决定何时，哪些功能被release （这实际上是Release Toggle），那么我们开发人员在不***意图***改变功能的前提下是可以不加toggle的，反之，影响到功能了，PO也在意那必须加toggle，这个不是技术上的问题，往大了说是产品策略的问题，不是开发人员说了算的。这里其实有个潜在待明确的概念：什么是功能什么不是功能，我觉得答案可以很简单：PO提出的，在意的就是功能，她不知道的不在意的就是不是。

## 如果一个新功能的开发触及了对已有数据库表格结构的改动，Toggle还能做吗？  
这个场景经常被拿出来讨论，要求是：新的功能只有在toggle打开时才起效，在此之前老的功能起效，有新老切换的可能。这实际上要求了***在一段时间内，我们的代码同时提供了新老功能***，随着toggle的开与关在两者之间切换；但我的改动触及了数据库结构了，不做处理这极有可能会破坏老的功能。  

为了支撑这种产品策略，针对这类开发，我想可以分几步走：
- 第一步，目标是对数据库进行兼容性修改，让它足以支撑新老功能  
像加个字段，加个表这种改变本身就不会破坏已有数据，直接可以在数据库上进行。如果是字段截短，那么也可以先不动，去下一步改代码，让所有数据渐渐都变成截断后的状态（是不是可以考虑直接写个migration程序？也可以嘛）。如果是删除字段或删除表那我们在这一步就可以什么都不做，去调整代码，然后等到第四步再干掉。
- 第二步，目标是让老的功能可以在改后的数据库结构上运行  
通过这一步，我们平抑了数据库改动带来的影响，做好这一步我们就可以向线上去push了，因为老功能还在并可运行。  
- 第三步，目标是加入新功能，提供Feature toggle  
数据库都准备好了，这里要加新代码引入新功能，注意保护老功能的代码，在做新的时候不破坏老的功能。这步应该比较容易达成。  
- 第四步，目标是移除feature toggle，清理数据库，清理代码库
feature toggle没必要之时，就是我们新功能完全取代老功能之日，那我们就可以放心去清理数据库了。现实中我们不能忘记这一步，不然长尾效应会给项目组带来许多负担。  

上面这个过程肯定不能解决所有的复杂数据库改动问题，但大多数的情况应该行的通，大规模不兼容改动一直发生是不太正常的。同时我们也可以把一个特别大的改动碎片化，经过一段时间的逐个处理，最终达到目的。

其实技术手段肯定有，主要是我们自己思想上要有“能做”的信念，而不是咬定“不好做”去推PO不做这个功能或是牺牲新老切换的便利。

另外在这个[链接中](https://featureflags.io/feature-flags-database-migrations/)，作者分析了完全的数据库切换 - 开始用MangoDB，之后切换到其它一种 - 时如何用toggle来辅助完成，比较有启发性，建议看看。总的来说步骤可以用下图描述：  
![dbmigration](images\ft5.jpg)

## 拿掉Toggle的同时，清理相关代码  
这个容易忘，所有这些Toggle Point上的代码在新功能替代老功能后都可以简化，它们是废弃代码会污染我们的设计。  在[这个链接中](https://dzone.com/articles/feature-toggles-are-one-worst)，作者把Feature Toggle看作是最糟糕的技术债而应该尽量避免。

## 自动化测试与Feature Toggle  
这个在上一篇里也有讨论，这里再明确一下。我们讨论前后端分离的项目，假设前端UI5后端Java。后端的自动化主要包含：  
- UT
- Integration （如Spring MockMvc）  
前端自动化测试包括：  
- UT （QUnit）
- Integration （如SAP OPA）  
- UI E2E测试 （如Webdriver.io脚本）  

对于UT，无论前后端，都相对好处理：针对每个toggle的每种情况我们都尽量覆盖到就完了, 这个和没有考虑toggle是否存在而是仅仅考虑一个个代码分支没有区别，覆盖它们天经地义。

对于Integration可能就比较棘手了，因为会涉及toggle组合的爆炸，把这些组合都测到是不可能的（5个toggle的话，将有32种组合，CALM Build目前我们有不下20个Toggle），那么我们要有选择性地进行组合测试，在[这个链接中](https://launchdarkly.com/blog/testing-with-feature-flags/)给出的建议感觉不错：  
- 测试当前线上版本正在打开的toggle组合（Test the current production state）
- 测试Toggle服务不可用的情形（Test for disaster scenario)  
这个适用于那种由单独服务来提供toggle决定结果的情况。那么当这个服务不可用的时候，toggle会有默认结果，这个默认结果的组合是否能正常工作呢？这个需要考虑一下。 但感觉如果toggle router的代码也是自己的，toggle configuration也在自己服务的范围内，那么没有必要做这个。  
- 对于结果决定于当前User Request的Toggle  
这类Toggle往往会与不同的persona相对应，那么我们可以选取比较典型的persona，确保它们会激活对应的toggle决定结果。

对于UI E2E脚本的创建策略我觉得和Integration情况类似。并且这类脚本会更少，只覆盖主线。

为了能更好的支持前后端Integration和UI E2E的测试，技术上要有办法让脚本去读取和改变Toggle的配置值。虽然可能很累，但前后端的Integration还是有可能Test Double来达到目的的，但前端的UI E2E肯定做不到，***这就要求我们提供修改这些Toggle的Endpoint（肯定不是让所有人能用），并且不能引入安全隐患***。

