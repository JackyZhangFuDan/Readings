# 行为驱动开发 - Behavior Driven Development  

名字从英文直译过来稍显奇怪，不知道有没有其它更好的翻译。下面用到的时候我就直接用BDD来指代了。

## 是什么，解决什么问题

肯定有很多人对BDD陌生，国内软件企业非常看重最终结果却不是特别重视过程，而BDD恰恰在过程这个领域，所以应用的不是特别广泛知道的人自然就少一些。**它是一种软件开发的开展方式，它保证在团队内创造针对需求的共识**，谈它挑战的问题的话需要从敏捷开始。敏捷开发想解决的问题是什么大家肯定多少都有了解，它减少从需求到反馈的时长，从而让软件更贴近市场，整个团队 - 包括PO - 频繁地对表，不让我们的工作偏离正确方向。一个正常的敏捷团队（以Scrum为例）必备如下角色：开发者，测试者，需求管理者（Product Owner），牵头人或者叫管家（Scrum Master）。日常工作的开展围绕那几个著名会议展开：Planning，Daily，Review， Retrospective，周而复始。PO给出的需求可以说是所有工作的前置条件，我在我的各个项目里每次都会化不少精力和PO建立如何定义好需求的共识，甚至格式是什么样子都会提前确定并不断根据教训加强，也会要PO在下一个项目周期前2天发出新的需求给团队。即使这样，我们的两周一次的Planning meeting也还是要开4个小时以上，大多讨论是理解需求，当然我们的PO和我们开发团队不在一个国家办公是造成额外开销的重要原因，但根本原因是人的思维方式太不同了，背景知识差异也太大了，一段PO觉得清楚无误的话开发看了就问题多多。你看，事实证明，**需求的传递并没有因为应用敏捷开发模式而变得完全无损**。其实人类社会早有手段应付这类问题了：正规化。例如USB接口的推广，wifi制式的统一，都是这个路子，大家做同一件事情的时候不要各行其是，按照约定好的规则来！**BDD为我们制定了一种需求理解的过程，它的产出是针对需求的正规化的再表述，一种简单明了的再表述**。

其实说到这里BDD的意义就说完了，就是理解需求用的过程，避免交流失误，最终统一全部成员的理解。但BDD流行起来的一个重要原因是有一拨人做了件特别NB的事情，咱上面说BDD会最终产出一种”针对需求的正规化的再表述“，这些人开发了软件工具，**把这些”再表述“和团队做的自动化测试用例关联了起来！**大家知道，测试用例的目标是发现软件实现与需求的不符合之处，是团队一个开发周期所产出成果的重要衡量尺度，那么**这种关联实际是完全自动化了”针对开发目标是否达成的评定“**。  
![bdd1](images/bdd1.PNG)  
自动化就意味着我可以高频次地跑，如果自动化测试脚本能在开发周期中期完成，那么我们随时可以掌握团队地开发进度，有多少既定功能已经实现了一目了然；如果自动化测试脚本不够及时只能在开发周期末期完成，那么我们至少可以在那时通过它们快速做评定，机器机械地做毕竟比人带着很大不确定性去做更可靠；如果测试脚本只能在开发周期结束后才完成，那也不是没有好处，它们还可以被用于后续迭代地回归测试嘛。总之，这种关联使得我们在不断地迭代过程中随时掌握所有实现了的功能的当前状态，**这使得BDD产出了一份活的产品功能文档。** 这样的效果是很多软件团队都梦寐以求的，所以自动化也逐渐被纳入BDD的方法论，作为延申出现。

我们需要把BDD和“Test Driven Development”区分开。TDD是说我们开发代码要写测试用例在先，主要是单元测试，测试用例要先写并要认真写，体现你的目标方法所要实现的目标。虽然二者名字只有一词之差，但二者完全不同。首先它们解决的问题所在层次不同，BDD是需求理解方面，而TDD是开发工作的方式；其次它们的参与者不同，BDD要全员参与，而TDD主要是开发人员（程序猿）来执行；再有就是发生的时间不同，BDD是一个迭代周期开始的第一件事情，TDD那是已经动手去实现了。

我们不要误把BDD当成一种”自动化测试“的方法论。**如果谈主业，BDD就和测试没有任何关系**。误解来源于BDD社区实现了BDD针对需求的正规化表述和自动化测试脚本的连接，测试脚本是实实在在要落实在系统里面的东西，所以给团队的印象是”要用BDD了，我要写自动化测试“，于是一头扎进Feature file，cucumber这些东西中去。记住，”BDD“和”连接BDD的产出和自动测试“是两回事。

## BDD过程

在软件工程领域，成功的流程往往是简单的，BDD也不例外，至少看起来是简单的。概括来说，BDD有三步：
+ 需求探索  
这一阶段整个团队坐在一起，用制定好的步骤来理解需求，具体方式下面展开。
+ 需求正规化  
需求理解完毕，那么我们需要用一种简洁正规，人与机器都能理解的方式表示出来。要求让机器也能懂主要是考虑到接下来的自动化。  
+ 自动化 （BDD的延申）  
基于得到的机器也能理解的需求表述，测试人员编织自动化测试脚本，最后通过工具（cucumber）的帮助，把脚本和需求表述连接起来。

## 第一步：需求探索

一切从PO的需求开始，一个迭代周期开始于对这些需求的分析。分析需要一些具体的形式，这一点很多团队实际上没有意识到的，我相信很多团队都只是坐在一个会议室里单纯地讨论，聊到哪里是哪里，理解是否完整全看当天状态。这种”朴素“的模式并非不会成功 - 如果我们的PO和团队始终呆在一起，如果你们有一个很棒的Scrum Master，能够时刻把大家的讨论方向聚焦，那么效果很有可能是有保证的，只是过程会痛苦一点儿而且Scrum Master本人非常痛苦，我自己深有体会。BDD里需求探索的工作在一个又一个”Requirement Workshop“里完成，在这个workshop中，**针对需求进行Structured Conversation，说白了就是有序讨论而不是叽叽喳喳**，例如团队以使用”Example Mapping“的方式来进行需求理解，但并不强制使用Example Mapping，也可以用自己成熟好用的需求理解过程替代，重点是你们的讨论是“Structured”的。

所谓“Structured Conversation“，有如下特点：
+ 群策群力共同参与。最好包括PO的全员，大家是建设性讨论，而不是互相拆台，逞英雄
+ 思路多样，视角多样。不然大家从一开始结论都一致，没啥讨论的
+ 短。这样的讨论不要持续太长，耗尽了大家热情，例如每个Requirement Workshop不超过1小时
+ 注意向前推进。很多时候与会者都忘记了在讨论什么，组织者要及时把大家拉回来向前推进
+ 共识。最后我们要给出达成的共识是什么，确保每个人都理解了这些共识

我们来看看Example Mapping是怎么玩儿的。PO给的需求往往是一段文字，好一点儿的PO会指定明确验收标准，我们叫Acceptance Criteria；忙一点儿的PO的话可能就只有文字描述了。在进行Example Mapping时，组织者要求所有与会者给出反应该需求的一个个基于实际数据，功能的例子，例子的描述要包含三个部分：  
+ 背景信息（Context）  
你在软件上做这组操作前软件的状态，例如系统里已经有的数据。这里肯定只给出和你的例子特别相关的背景信息，而不是面面俱到给出所有，那些次要，显而易见的必备条件等，就不用再累述了  
+ 操作步骤（Action）
接下来你是怎么在软件上操作的呢？ 描述一下  
+ 结果，产出 （Output）  
你这一通操作下来，系统会产生什么结果？  


## 第二步：需求正规化
## 第三步：自动化